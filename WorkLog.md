# 记录一下机械臂制作过程，碰到的困难问题和挑战

## 电机

### 2024-05-10
在代码里测试了GPIO，ADC都没问题，但是SPI的NSS引脚PA4一直没有信号，我在代码中设置了每次SPI通信前将PA4置低电平开启MT6816，通信完置高电平关闭。
通过逻辑分析仪抓取发现NSS PA4引脚一直是低电平，代码中将PA4换成其他引脚PB8最为对照，然后测PB8引脚能抓到和代码吻合的电平变化，证明逻辑代码没问题。
最后将PA4引脚功能从SPI_NSS换成GPIO输出，然后问题就搞定了，从MT6816读取的数据很稳定，不飘，手按住电机转子稍微用力旋转，即使是弹性转动也能探测到数据变化，
松手数据也会回弹到之前的数据，证明电路设计也没有问题。接下来可以测试电机转动了。

#### 
[42步进电机接线](https://www.bilibili.com/read/cv5637376/)
- 判断哪两个引脚是一组线圈可以用万用表测电阻，如果电阻很小那么就是一组线圈
- 电流控制扭矩

### 2024-05-11
- 使用基本的8 step比较丝滑的电机正反转，至此所有的底层功能，外设都验证完成（DMA还没专门验证，不过应该没问题）。唯一一个例外是温敏电阻VCC搞错了，设置成了12v导致之前芯片引脚电压不对，所以温敏电阻adc读取的值无效，之后在新版本中修改。

- 研究怎么将底层硬件配置完全抽象出来，用c++ class封装一遍，保证上层软件和底层硬件配置解耦，方便以后灵活修改底层配置。

### 2024-05-12 - 15
- 将底层基本外设都剥离到单独的c文件，然后开始将c文件里的功能函数抽象出来提供给上层C++ class。比如adc.hpp 中的adc class 调用adc.c 的函数，此外，使用inline内联避免多次函数调用的额外开销。

### 2024-05-17 - 18
- 抽象出驱动层，mt67816, tb67h450等.

### 2024-05-19 
- 测试了简单的开环foc算法，控制电机丝滑转动

### 2024-05-20
- 优化和测试了Timer类，测试没有问题，可以用20khz为主任务，但是其他timer的中断处理必须尽量少消耗计算资源，不然主任务会受到干扰比如电机转动明显有顿挫一些。

- 研究了控制算法的原理

根据驱动硬件决定了对电机的控制只有三个方面：
1. 控制电机线圈两端是否通电以及方向，也就是AIN1，2 BIN1，2的电平
2. 通过vref控制电机驱动最大输出电流
3. 通过50us一次的控制算法任务中，控制每次电机走的步数，在foc中，可以将每个1.8度的整步都进行256细分，而控制电机转动指定细分步数，其实就是设置对应的两组线圈的电流值。也就是说，设置电流就能间接控制电机转动速度。

根据上面的分析，不难得出最核心的控制就是控制电流，具体来说就是控制vref的值，AIN1，2 BIN1，2只是配合设置方向。最本质的还是控制电流，这也是为什么pid算法的输出是电流值。
当然对TB67H450的控制并不能设置真实的电流值，而是设置最大电流输出，但是它内部实现了电流闭环，会将电流稳定在所需的最小值，所以我们最终只需要通过对最大电流输出的控制就能让电机丝滑转动。

TB67H450电机驱动IC的作用：
不仅能限制最大输出电流，还具有内部的闭环控制系统，确保实际电流稳定在所需的最小值。具体来说：

最大电流限制：保护电机不受过流损坏。
斩波恒流控制：通过快速开关电源调节电流，保持电流在设定范围内。
闭环电流控制：实时监测和调节电流，使其尽量接近所需的值。

参考资料：
https://github.com/peng-zhihui/Dummy-Robot/tree/main/2.Firmware/Ctrl-Step-Driver-STM32F1-fw
https://zhuanlan.zhihu.com/p/670162318

### 2024-05-21 - 22
- 调试uart dma，结果总是有重复发送等奇奇怪怪的问题。
结果发现是dma设置成了circular的，所以调用一次HAL_UART_Transmit_DMA就会连续不断的从给的地址复制内容然后发送，所以就算只调用一次也会不断重复发送。
解决办法： 
1. 将dma模式从circular改成normal
2. 开启uart global interrupt以便接收传输完成的callback。

- 尝试使用vofa+串口调试工具，也是上述问题导致显示不正常，解决之后显示正常了，firewater格式下，多个数据用逗号隔开，字符串末尾加"\n", 不需要"\r".
  鼠标放到y轴坐标区域滚动滚轮可以缩放y轴，不然就都是缩放x轴。 在y轴坐标区域按住左键上下移动拖动线条上下的位置

- 关于dma 用在tx:
1. Normal模式，手动调用HAL_UART_Transmit_DMA发送数据，等待完成的信号来到后可以再次调用这个函数发送
2. circular模式，调用一次HAL_UART_Transmit_DMA之后会不间断的连续发送，如果不及时对缓冲区进行清空或覆盖，就会导致重复发送
   可以尝试使用TxHalfCpltCallback信号，两倍长度的缓冲区，一次完整数据只占一般的缓冲区，这样TxHalfCpltCallback信号过来就说明
   一次数据已经发送完毕，可以用两个半个缓冲区交替传入数据。

### 2024-05-23
- 发现开源的电机控制算法还是有一些不懂，把XDrive项目下载下来先研究研究再接着写

## 问题
### Cmake:
- Cmake 配置信息从最外层到最里层传递。